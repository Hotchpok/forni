# Функция для поиска кратчайшего пути в лабиринте
def find_shortest_path(maze):
    # Инициализация переменных для стартовой и конечной точеккк
    start = None
    end = None

    # Поиск стартовой ('С') и конечной ('В') точек в лабиринте
    for i in range(len(maze)):  # Перебор строк лабиринта
        for j in range(len(maze[i])):  # Перебор столбцов в текущей строке
            if maze[i][j] == 'С':  # Если найдена стартовая точка
                start = (i, j)  # Запоминаем координаты старта
            elif maze[i][j] == 'В':  # Если найдена конечная точка
                end = (i, j)  # Запоминаем координаты выхода

    # Проверка, что обе точки найдены
    if not start or not end:
        return None, "Нет старта или выхода в лабиринте!"

    # Возможные направления движения (вверх, вниз, влево, вправо)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # Инициализация очереди для поиска в ширину
    queue = []
    # Добавляем стартовую точку в очередь: (x, y, расстояние, путь)
    queue.append((start[0], start[1], 0, [start]))

    # Множество для отслеживания посещенных точек
    visited = set()
    visited.add(start)  # Помечаем стартовую точку как посещенную

    # Основной цикл поиска в ширину
    while queue:
        # Извлекаем первый элемент из очереди
        x, y, dist, path = queue.pop(0)

        # Проверяем, достигли ли выхода
        if (x, y) == end:
            return dist, path  # Возвращаем длину и путь

        # Проверяем все возможные направления движения
        for dx, dy in directions:
            # Вычисляем координаты соседней клетки
            nx, ny = x + dx, y + dy

            # Проверяем, что новые координаты в пределах лабиринта
            if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]):
                # Проверяем, что клетка не является стеной и не посещена
                if maze[nx][ny] != 'X' and (nx, ny) not in visited:
                    visited.add((nx, ny))  # Помечаем как посещенную
                    new_path = path + [(nx, ny)]  # Обновляем путь
                    # Добавляем в очередь с увеличенным расстоянием
                    queue.append((nx, ny, dist + 1, new_path))

    # Если выход не найден после проверки всех возможных путей
    return None, "Путь не найден!"


# Пример лабиринта (0 - проход, X - стена, С - старт, В - выход)
maze = [
    ['С', '0', '0', '0', '0', 'X', '0', '0'],
    ['0', '0', 'X', '0', '0', 'X', '0', '0'],
    ['X', '0', 'X', '0', '0', 'X', '0', 'X'],
    ['0', '0', 'X', '0', '0', '0', '0', '0'],
    ['0', '0', 'X', '0', 'X', 'X', 'X', '0'],
    ['X', '0', '0', '0', '0', '0', '0', '0'],
    ['X', '0', '0', '0', 'X', '0', '0', 'В']
]

# Находим кратчайший путь
length, path = find_shortest_path(maze)

# Вывод результатов
if length is not None:
    print(f"Длина кратчайшего пути: {length}")
    print("Путь (координаты (строка, столбец)):")
    for step in path:
        # Выводим шаги пути с стрелочками между ними (кроме последнего)
        print(step, end=" → " if step != path[-1] else "\n")
else:
    # Выводим сообщение об ошибке, если путь не найден
    print(path)
